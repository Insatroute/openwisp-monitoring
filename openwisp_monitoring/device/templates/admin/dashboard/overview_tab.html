{% load leaflet_tags i18n %}
{% load i18n %}
{% load static %}
<script type="text/javascript">
  window._owGeoMapConfig = {
    geoJsonUrl: '{{ monitoring_location_geojson_url }}',
    locationDeviceUrl: '{{ monitoring_device_list_url }}?page_size=5'
  }
</script>

<!-- Chart.js v3+ -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

<script type="text/javascript" src={% static 'monitoring/js/lib/netjsongraph.min.js' %}></script>
<script type="text/javascript" src={% static 'monitoring/js/lib/leaflet.fullscreen.min.js' %}></script>

<div id='leaflet-config'>
  {% autoescape on %}{% leaflet_json_config %}{% endautoescape %}
</div>

<div class="map-view">
  <div id="device-map-container">
    <div class="no-data">
      <p>{% trans 'No map data to show' %}.</p>
      <p><a class="button submit" href="#close">Close</a></p>
    </div>
    <div class="ow-loading-spinner"></div>
  </div>
</div>

<div class="card-grid">
  <!-- Devices Card -->
  <div class="card">
    <h4>Devices</h4>
    <div class="stats">
      <div class="stat-item">
        <span class="badge badge-gray" id="total-devices">0</span>
        <span class="card-label">Total</span>
      </div>
      <div class="stat-item">
        <span class="badge badge-green" id="monitoring-ok">0</span>
        <span class="card-label">Online</span>
      </div>
      <div class="stat-item">
        <span class="badge badge-red" id="monitoring-critical">0</span>
        <span class="card-label">Offline</span>
      </div>
    </div>
  </div>

  <!-- Tunnels Card -->
  <div class="card">
    <h4>Tunnels</h4>
    <div class="stats">
      <div class="stat-item">
        <span class="badge badge-gray" id="spoke-total">0</span>
        <span class="card-label">Total</span>
      </div>
      <div class="stat-item">
        <span class="badge badge-green" id="spoke-active">0</span>
        <span class="card-label">Active</span>
      </div>
      <div class="stat-item">
        <span class="badge badge-yellow" id="spoke-pending">0</span>
        <span class="card-label">Pending</span>
      </div>
    </div>
  </div>

  <!-- Total Links Card -->
  <div class="card">
    <h4>Total Links</h4>
    <div class="stats">
      <div class="stat-item">
        <span class="badge badge-gray home-wan-total">0</span>
        <span class="card-label">Links</span>
      </div>
    </div>
  </div>

  <!-- Active Links Card -->
  <div class="card">
    <h4>Active Links</h4>
    <div class="stats">
      <div class="stat-item">
        <span class="badge badge-green home-wan-connected">0</span>
        <span class="label">Active</span>
      </div>
    </div>
  </div>
</div>

<!-- built-in OpenWISP charts -->
<div id="plot-container"></div>

<!-- ===== your three matching cards ===== -->
<div id="custom-distribution-row">
  <div class="custom-distribution-grid">

    <div class="ow-mini-card Carrier-Distribution-div">
      <h4 class="ow-mini-title Carrier-Distribution-span">Carrier Distribution</h4>
      <div class="ow-mini-inner">
        <div id="Carrier-Distribution-chart" class="ow-mini-plot"></div>
      </div>
      <div class="ow-mini-legend" id="Carrier-Distribution-legend"></div>
    </div>

    <div class="ow-mini-card Network-Distribution-div">
      <h4 class="ow-mini-title Network-Distribution-span">Network Distribution</h4>
      <div class="ow-mini-inner">
        <div id="Network-Distribution-chart" class="ow-mini-plot"></div>
      </div>
      <div class="ow-mini-legend" id="Network-Distribution-legend"></div>
    </div>

    <div class="ow-mini-card Interface-Distribution-div">
      <h4 class="ow-mini-title Interface-Distribution-span">Interface Distribution</h4>
      <div class="ow-mini-inner">
        <div id="Interface-Distribution-chart" class="ow-mini-plot"></div>
      </div>
      <div class="ow-mini-legend" id="Interface-Distribution-legend"></div>
    </div>

  </div>
</div>
<!-- =============================================== -->

<script>
  // ========= Build a light-weight JS array from device_data.interfaces =========
  // (No json_script, no API calls)
  const ifaces = JSON.parse(String.raw`
    [
      {% for iface in device_data.interfaces %}
      {
        "type": "{{ iface.type|default_if_none:''|escapejs }}",
        "name": "{{ iface.name|default_if_none:''|escapejs }}",

        "operator_name": "{% if iface.mobile %}{{ iface.mobile.operator_name|default_if_none:''|escapejs }}{% else %}{% endif %}",

        "has_lte": {% if iface.mobile and iface.mobile.signal.lte %}true{% else %}false{% endif %},
        "has_5g":  {% if iface.mobile and iface.mobile.signal.5g %}true{% else %}false{% endif %}
      }{% if not forloop.last %},{% endif %}
      {% endfor %}
    ]
  `);

  console.log("IFACES:=====", ifaces);

  /* ---------- Donut with clickable legend to hide/show slices ---------- */
  function renderDonutWithLegend(opts) {
    const { elId, legendId, labels, values, colors } = opts;

    const el = document.getElementById(elId);
    const legendRoot = document.getElementById(legendId);
    if (!el || !legendRoot) return;

    const baseValues = values.slice();                // keep originals
    const active = baseValues.map(v => v > 0);        // visibility mask

    function totalActive() {
      return baseValues.reduce((acc, v, i) => acc + (active[i] ? v : 0), 0);
    }

    // initial plot
    const rect = el.getBoundingClientRect();
    const data = [{
      type: 'pie',
      labels: labels,
      values: baseValues,
      hole: 0.69,
      sort: false,
      direction: 'clockwise',
      texttemplate: '%{value} (%{percent})',
      textposition: 'inside',
      insidetextorientation: 'auto',
      textfont: { size: 9, color: '#ffffff' },
      textinfo: 'none',
      hoverinfo: 'label+value+percent',
      marker: { colors: colors || [] }
    }];
    const layout = {
      height: Math.max(140, Math.floor(rect.height || 150)),
      width: rect.width || el.clientWidth || 200,
      margin: { l: 6, r: 6, t: 6, b: 6 },
      showlegend: false,
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      annotations: [{
        showarrow: false,
        text: String(totalActive() || 0),
        x: 0.5, y: 0.5,
        font: { size: 13, color: '#2b2f36' }
      }]
    };
    if (typeof Plotly === 'undefined') return;
    Plotly.newPlot(el, data, layout, { responsive: true, displayModeBar: false });

    // build legend
    legendRoot.innerHTML = '';
    labels.forEach((label, i) => {
      const item = document.createElement('div');
      item.className = 'legend-item';
      item.dataset.index = i;
      const sw = document.createElement('span');
      sw.className = 'legend-swatch';
      sw.style.background = (colors && colors[i]) ? colors[i] : '#353c44';
      const txt = document.createElement('span');
      txt.textContent = label;
      item.appendChild(sw);
      item.appendChild(txt);
      legendRoot.appendChild(item);
    });

    // legend click -> toggle slice
    legendRoot.addEventListener('click', (e) => {
      const node = e.target.closest('.legend-item');
      if (!node) return;
      const idx = parseInt(node.dataset.index, 10);
      active[idx] = !active[idx];

      const newVals = baseValues.map((v, i) => active[i] ? v : 0);
      Plotly.restyle(el, { values: [newVals] });
      Plotly.relayout(el, { 'annotations[0].text': String(totalActive() || 0) });
      node.classList.toggle('is-off', !active[idx]);
    });
  }

  /* ================== BUILD DATA FROM ifaces (NO JSON PARSE / API) ================== */

  function getDistributionsFromIfaces() {
    const carriersCount = new Map();   // operator_name => count
    const techCount = new Map();       // 4G / 5G / other => count
    const ifaceCount = new Map();      // interface.name => count

    for (const iface of ifaces) {
      if (!iface || !iface.name) continue;

      // Interface Distribution: per interface name
      const ifaceName = (iface.name || 'Unknown').trim();
      ifaceCount.set(ifaceName, (ifaceCount.get(ifaceName) || 0) + 1);

      // Only mobiles carry carrier + network tech info
      if (iface.type === 'mobile') {
        const op = (iface.operator_name || 'Unknown').trim() || 'Unknown';
        carriersCount.set(op, (carriersCount.get(op) || 0) + 1);

        if (iface.has_lte) {
          techCount.set('4G', (techCount.get('4G') || 0) + 1);
        }
        if (iface.has_5g) {
          techCount.set('5G', (techCount.get('5G') || 0) + 1);
        }
      }
    }

    // Carrier arrays
    const carrierLabels = Array.from(carriersCount.keys());
    const carrierValues = carrierLabels.map(k => carriersCount.get(k));

    // Network arrays with nice ordering
    const networkPreferredOrder = ['5G', '4G'];
    const allTechKeys = Array.from(techCount.keys());
    const orderedTech = [
      ...networkPreferredOrder.filter(k => techCount.has(k)),
      ...allTechKeys.filter(k => !networkPreferredOrder.includes(k))
    ];
    const networkLabels = orderedTech;
    const networkValues = networkLabels.map(k => techCount.get(k));

    // Interface arrays
    const interfaceLabels = Array.from(ifaceCount.keys());
    const interfaceValues = interfaceLabels.map(k => ifaceCount.get(k));

    return {
      carrierLabels,
      carrierValues,
      networkLabels,
      networkValues,
      interfaceLabels,
      interfaceValues
    };
  }

  /* ================== INIT (use ifaces) ================== */

  const palette1 = ['#ff7f0e', '#1f77b4', '#2ca02c', '#353c44', '#a72d1d', '#267126']; // carriers
  const palette2 = ['#2ca02c', '#1f77b4', '#353c44', '#a72d1d', '#f59e0b', '#22c55e']; // network
  const palette3 = ['#ff7f0e', '#1f77b4', '#2ca02c', '#353c44', '#a72d1d', '#22c55e', '#6366f1', '#0ea5e9']; // interfaces

  (function () {
    'use strict';

    // coerce "—" or empty string to null, otherwise keep string
    function coerceStr(raw) {
      if (raw == null) return null;
      const s = String(raw).trim();
      if (!s || s === '—') return null;
      return s;
    }

    // ========== 1) Build small JS objects from device_data like your csq example ==========

    // NOTE: these follow your pattern:
    //   csq: coerceNum("{{ device_data.cellular.modem.csq|default:'—' }}"),
    // here we do the same for operator/nettype, etc.

    const modem1 = {
      operator: coerceStr("{{ device_data.cellular.modem.operator|default:'—' }}"),
      nettype: coerceStr("{{ device_data.cellular.modem.nettype|default:'—' }}")
    };

    const modem2 = {
      operator: coerceStr("{{ device_data.cellular.modem2.operator|default:'—' }}"),
      nettype: coerceStr("{{ device_data.cellular.modem2.nettype|default:'—' }}")
    };

    // ========== 2) Interface list from device_data.interfaces (names only) ==========

    // We build a JSON array using Django in a JS string and parse it.
    // No json_script, but safe and simple.
    const interfaceNames = JSON.parse(String.raw`
      [
        {% for iface in device_data.interfaces %}
          "{{ iface.name|default_if_none:''|escapejs }}"{% if not forloop.last %},{% endif %}
        {% endfor %}
      ]
    `).filter(Boolean);  // remove empty strings

    // ========== 3) Build distributions ==========

    console.log("Modem1:====", modem1);
    console.log("Modem2:====", modem2);
    console.log("Interface Names:====", interfaceNames);

    // ---- Carrier Distribution (by operator) ----
    const carriersCount = new Map();
    [modem1, modem2].forEach(m => {
      if (!m || !m.operator) return;
      const key = m.operator.toUpperCase();
      carriersCount.set(key, (carriersCount.get(key) || 0) + 1);
    });

    const carrierLabels = carriersCount.size
      ? Array.from(carriersCount.keys())
      : ['Unknown'];
    const carrierValues = carriersCount.size
      ? carrierLabels.map(k => carriersCount.get(k))
      : [0];

    // ---- Network Distribution (4G / 5G using nettype) ----
    const netCounts = new Map(); // key: '4G' / '5G' / other
    [modem1, modem2].forEach(m => {
      if (!m || !m.nettype) return;
      let t = m.nettype.toUpperCase();
      if (t.includes('LTE')) t = '4G';
      if (t.includes('NR') || t.includes('5G')) t = '5G';
      netCounts.set(t, (netCounts.get(t) || 0) + 1);
    });

    const preferredOrder = ['5G', '4G'];
    const netLabels = netCounts.size
      ? [
        ...preferredOrder.filter(t => netCounts.has(t)),
        ...Array.from(netCounts.keys()).filter(t => !preferredOrder.includes(t))
      ]
      : ['4G', '5G'];

    const netValues = netCounts.size
      ? netLabels.map(t => netCounts.get(t))
      : [0, 0];

    // ---- Interface Distribution (by interface.name) ----
    const ifaceCount = new Map();
    interfaceNames.forEach(n => {
      const key = n || 'unknown';
      ifaceCount.set(key, (ifaceCount.get(key) || 0) + 1);
    });

    const ifaceLabels = ifaceCount.size
      ? Array.from(ifaceCount.keys())
      : ['eth0', 'eth1', 'modem', 'modem2'];

    const ifaceValues = ifaceCount.size
      ? ifaceLabels.map(k => ifaceCount.get(k))
      : [0, 0, 0, 0];

    // ========== 4) Render the three donuts using your existing helper ==========

    const palette1 = ['#ff7f0e', '#1f77b4', '#2ca02c', '#353c44', '#a72d1d', '#267126']; // carriers
    const palette2 = ['#2ca02c', '#1f77b4', '#353c44', '#a72d1d', '#f59e0b', '#22c55e']; // network
    const palette3 = ['#ff7f0e', '#1f77b4', '#2ca02c', '#353c44', '#a72d1d', '#22c55e', '#6366f1', '#0ea5e9']; // interfaces

    function go() {
      // 1) Carrier Distribution
      renderDonutWithLegend({
        elId: 'Carrier-Distribution-chart',
        legendId: 'Carrier-Distribution-legend',
        labels: carrierLabels,
        values: carrierValues,
        colors: palette1
      });

      // 2) Network Distribution
      renderDonutWithLegend({
        elId: 'Network-Distribution-chart',
        legendId: 'Network-Distribution-legend',
        labels: netLabels,
        values: netValues,
        colors: palette2
      });

      // 3) Interface Distribution
      renderDonutWithLegend({
        elId: 'Interface-Distribution-chart',
        legendId: 'Interface-Distribution-legend',
        labels: ifaceLabels,
        values: ifaceValues,
        colors: palette3
      });
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      go();
    } else {
      document.addEventListener('DOMContentLoaded', go);
    }
  })();
</script>

{% leaflet_js %}

<script>
  let cachedToken = sessionStorage.getItem('cachedToken') || '80ee082483ee2a41d520909e571a3970f06d5907';

  async function fetchAuthToken() {
    if (cachedToken) return cachedToken;
    // add real token logic here if needed
  }

  async function fetchDeviceData() {
    const token = await fetchAuthToken();
    if (!token) {
      document.getElementById('total-devices').innerText = 'Auth error';
      document.getElementById('monitoring-ok').innerText = 'Auth error';
      document.getElementById('monitoring-critical').innerText = 'Auth error';
      return;
    }

    try {
      const response = await fetch(`${window.API_BASE_URL}/api/v1/monitoring/device`, {
        headers: {
          'Accept': 'application/json',
          'Authorization': `Token ${token}`
        }
      });
      const data = await response.json();

      const totalDevices = data.count ?? (Array.isArray(data.results) ? data.results.length : 0);
      document.getElementById('total-devices').innerText = totalDevices;

      let okStatusCount = 0;
      let criticalStatusCount = 0;
      const devices = data.results || [];
      devices.forEach(device => {
        const status = device.monitoring?.status;
        if (status === 'ok') okStatusCount++;
        else if (status === 'critical') criticalStatusCount++;
      });

      document.getElementById('monitoring-ok').innerText = okStatusCount;
      document.getElementById('monitoring-critical').innerText = criticalStatusCount;

    } catch (error) {
      console.error('Error fetching device data:', error);
      document.getElementById('total-devices').innerText = '0';
      document.getElementById('monitoring-ok').innerText = '0';
      document.getElementById('monitoring-critical').innerText = '0';
    }
  }

  async function fetchSpokeData() {
    const elems = {
      total: document.getElementById('spoke-total'),
      active: document.getElementById('spoke-active'),
      pending: document.getElementById('spoke-pending'),
    };
    if (Object.values(elems).some(el => !el)) {
      console.error('One or more spoke DOM elements not found.');
      return;
    }

    Object.values(elems).forEach(el => el.innerText = '0');

    let token;
    try {
      token = await fetchAuthToken();
    } catch (e) {
      console.error('Token fetch failed', e);
    }
    if (!token) {
      Object.values(elems).forEach(el => el.innerText = 'Auth error');
      return;
    }

    let json;
    try {
      const resp = await fetch(`${window.API_BASE_URL}/api/v1/spoke/`, {
        headers: {
          'Accept': 'application/json',
          'Authorization': `Token ${token}`
        }
      });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      json = await resp.json();
    } catch (err) {
      console.error('Error fetching spoke data:', err);
      Object.values(elems).forEach(el => el.innerText = '0');
      return;
    }

    const items = Array.isArray(json) ? json : [];
    const counts = items.reduce((acc, { status }) => {
      const st = status || 'error';
      acc[st] = (acc[st] || 0) + 1;
      return acc;
    }, {});

    const result = {
      active: counts.active || 0,
      pending: counts.pending || 0,
      error: counts.error || 0,
    };
    result.total = Object.values(result).reduce((sum, v) => sum + v, 0);

    elems.total.innerText = result.total;
    elems.active.innerText = result.active;
    elems.pending.innerText = result.pending;
  }

  document.addEventListener('DOMContentLoaded', () => {
    fetchDeviceData();
    fetchSpokeData();

    setInterval(fetchDeviceData, 30000);
    setInterval(fetchSpokeData, 30000);
  });
</script>

{% leaflet_css %}

<style>
  .leaflet-bottom {
    display: none !important;
  }

  .js-plotly-plot.currently-active-wifi-sessions {
    display: none !important;
  }

  .js-plotly-plot.system-type {
    display: none !important;
  }

  #custom-distribution-row {
    margin: 0 auto 0;
    padding: 10px 40px 10px 40px;
  }

  .custom-distribution-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(240px, 1fr));
    gap: 22px;
  }

  @media (max-width: 1100px) {
    .custom-distribution-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 720px) {
    .custom-distribution-grid {
      grid-template-columns: 1fr;
    }
  }

  .ow-mini-card {
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, .1);
    padding: 14px;
    max-width: 500px;
    height: 280px;
  }

  @media screen and (max-width: 7680px) {
    .ow-mini-card {
      max-width: 1690px;
    }
  }

  @media screen and (max-width: 1536px) {
    .ow-mini-card {
      max-width: 1000px;
    }
  }

  .ow-mini-title {
    text-align: center;
    margin: 0 0 8px 0;
    font-size: 13px;
    font-weight: 480;
    color: #2b2f36;
  }

  .ow-mini-inner {
    margin-top: 30px;
    background: #fbfbfb;
    border-radius: 12px;
    height: 150px;
    overflow: hidden;
    position: relative;
  }

  .ow-mini-plot {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .ow-mini-legend {
    display: grid;
    align-items: center;
    justify-content: center;
    padding: 8px 6px 2px 6px;
  }

  .legend-item {
    display: inline-flex;
    align-items: center;
    font-size: 12px;
    color: #374151;
    white-space: nowrap;
    cursor: pointer;
    user-select: none;
    transition: opacity .15s ease, color .15s ease;
  }

  .legend-item.is-off {
    opacity: .45;
    text-decoration: line-through;
  }

  .legend-swatch {
    width: 12px;
    height: 12px;
    margin-right: 6px;
    background: #353c44;
    flex: 0 0 auto;
  }

  .svg-container .main-svg {
    background: rgb(255 255 255 / 0%) !important;
  }

  .content {
    background-color: #d3d3d30f !important;
  }

  .card-grid {
    display: grid;
    grid-gap: 20px;
    grid-template-columns: repeat(4, 1fr);
    margin: 10px auto;
    padding: 10px 40px 10px 40px;
  }

  .card {
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    padding: 1rem;
    text-align: center;
  }

  .stats {
    display: flex;
    justify-content: space-around;
    margin-top: 10px;
  }

  .stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 13px;
  }

  .badge {
    padding: 5px 10px;
    border-radius: 10px;
    font-weight: 600;
    font-size: 13px;
    margin-bottom: 4px;
  }

  .badge-gray {
    background: #e0e0e0;
    color: #333;
  }

  .badge-green {
    background: #28a745;
    color: #fff;
  }

  .badge-red {
    background: #dc3545;
    color: #fff;
  }

  .badge-yellow {
    background: #FFA500;
    color: #333;
  }

  .card-label {
    font-size: 12px;
    color: #666;
  }

  @media screen and (max-width: 1024px) {
    .card-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media screen and (max-width: 600px) {
    .card-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .badge {
      font-size: 11px;
      padding: 4px 8px;
    }
  }
</style>