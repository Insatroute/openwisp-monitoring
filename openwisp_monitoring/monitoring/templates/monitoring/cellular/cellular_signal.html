<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Cellular Signal Charts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    .cellular_signal_page {
      max-width: 1100px;
      margin: 24px auto;
      padding: 0 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
    }

    .cellular_signal_header {
      display: flex;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 18px;
      flex-wrap: wrap;
    }

    .cellular_signal_title {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
    }

    .cellular_signal_subtitle {
      margin: 0;
      font-size: 14px;
      color: #666;
    }

    .cellular_signal_grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }

    .cellular_signal_card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, .06), 0 1px 2px rgba(0, 0, 0, .08);
      padding: 14px;
    }

    .cellular_signal_card h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    .cellular_signal_chartwrap {
      display: flex;
      justify-content: center;
    }

    .cellular_signal_plot {
      width: 100%;
      max-width: 1000px;
      height: 280px;
      margin: 0 auto;
    }

    .cellular_signal_plot.js-plotly-plot,
    .cellular_signal_plot .plot-container,
    .cellular_signal_plot .svg-container {
      width: 100% !important;
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #f3f4f6;
      font-size: 12px;
      color: #374151;
    }
  </style>
</head>

<body>

  <div class="cellular_signal_page">
    <div class="cellular_signal_header">
      <h1 class="cellular_signal_title">Cellular Metrics</h1>
      <p class="cellular_signal_subtitle" id="cellular_signal_meta"></p>
    </div>

    <div class="cellular_signal_grid">
      <div class="cellular_signal_card">
        <h3>Signal Strength (Level)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_csq" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>RSRP (dBm)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_rsrp" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>RSRQ (dB)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_rsrq" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>RSSI (dBm)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_rssi" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>SNR (dB)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_snr" class="cellular_signal_plot"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {

      /* ========= 0. Storage key per device (so routers don't mix history) ========= */
      const serialNumber = "{{ device_data.general.serialnumber|default:'unknown' }}";
      const STORAGE_KEY = "cellular_history_" + serialNumber;

      /* ---------- Helper to parse Django local_time (ISO or "12 Nov 2025, 10:50 p.m.") ---------- */
      function parseLocalTime(raw) {
        if (!raw) return null;

        // 1) try native Date (ISO "2025-11-12T22:50:26+05:30" etc.)
        let d = new Date(raw);
        if (!isNaN(d.getTime())) return d;

        // 2) try "12 Nov 2025, 10:50 p.m."
        const m = raw.match(/(\d{1,2})\s+([A-Za-z]{3})\s+(\d{4}),\s+(\d{1,2}):(\d{2})\s*([ap]\.m\.)/i);
        if (m) {
          const day = parseInt(m[1], 10);
          const monthName = m[2].toLowerCase();
          const year = parseInt(m[3], 10);
          let hour = parseInt(m[4], 10);
          const minute = parseInt(m[5], 10);
          const ampm = m[6].toLowerCase();

          const monthMap = {
            jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5,
            jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11
          };
          const monthIdx = monthMap[monthName] ?? 0;

          if (ampm.startsWith('p') && hour < 12) hour += 12;
          if (ampm.startsWith('a') && hour === 12) hour = 0;

          d = new Date(year, monthIdx, day, hour, minute, 0, 0);
          if (!isNaN(d.getTime())) return d;
        }

        // 3) last resort – current time
        return new Date();
      }

      /* ====== 1. Read one snapshot from Django (local_time + modem values) ====== */
      function getSampleFromDjango() {
        const rawLocalTime = "{{ device_data.general.local_time|default:'' }}";
        console.log("Raw local_time:====", rawLocalTime);

        const ts = parseLocalTime(rawLocalTime || '2025-11-12T21:32:54+05:30');

        function coerceNum(v) {
          if (v == null || v === '—' || v === '-' || v === '') return 0;
          const n = parseFloat(v);
          return isNaN(n) ? 0 : n;
        }

        return {
          timestamp: ts,
          m1: {
            csq: coerceNum("{{ device_data.cellular.modem.csq|default:'—' }}"),
            rsrp: coerceNum("{{ device_data.cellular.modem.rsrp|default:'—' }}"),
            rsrq: coerceNum("{{ device_data.cellular.modem.rsrq|default:'—' }}"),
            rssi: coerceNum("{{ device_data.cellular.modem.rssi|default:'—' }}"),
            snr: coerceNum("{{ device_data.cellular.modem.sinr|default:'—' }}"),
            operator: "{{ device_data.cellular.modem.operator|default:'—' }}",
            nettype: "{{ device_data.cellular.modem.nettype|default:'—' }}"
          },
          m2: {
            csq: coerceNum("{{ device_data.cellular.modem2.csq|default:'—' }}"),
            rsrp: coerceNum("{{ device_data.cellular.modem2.rsrp|default:'—' }}"),
            rsrq: coerceNum("{{ device_data.cellular.modem2.rsrq|default:'—' }}"),
            rssi: coerceNum("{{ device_data.cellular.modem2.rssi|default:'—' }}"),
            snr: coerceNum("{{ device_data.cellular.modem2.sinr|default:'—' }}"),
            operator: "{{ device_data.cellular.modem2.operator|default:'—' }}",
            nettype: "{{ device_data.cellular.modem2.nettype|default:'—' }}"
          }
        };
      }

      /* ====== 2. Load / save history in localStorage ====== */

      function loadHistoryFromStorage() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return [];
          const arr = JSON.parse(raw);
          if (!Array.isArray(arr)) return [];
          return arr.map(function (s) {
            return {
              timestamp: new Date(s.timestamp),
              m1: s.m1 || {},
              m2: s.m2 || {}
            };
          }).filter(function (s) {
            return !isNaN(s.timestamp.getTime());
          });
        } catch (e) {
          console.error('Failed to load cellular history from storage:', e);
          return [];
        }
      }

      function saveHistoryToStorage(history) {
        try {
          const plain = history.map(function (s) {
            return {
              timestamp: s.timestamp.toISOString(),
              m1: s.m1,
              m2: s.m2
            };
          });
          localStorage.setItem(STORAGE_KEY, JSON.stringify(plain));
        } catch (e) {
          console.error('Failed to save cellular history to storage:', e);
        }
      }

      /* ====== 3. In-memory history (+ trimming to last 24h) ====== */

      let history = loadHistoryFromStorage(); // oldest → newest after we sort below

      function addSample(sample) {
        if (!sample || !sample.timestamp || isNaN(sample.timestamp.getTime())) return;

        history.push(sample);

        // sort by time
        history.sort(function (a, b) {
          return a.timestamp - b.timestamp;
        });

        // keep only last 24 hours (based on latest sample)
        const lastTs = history[history.length - 1].timestamp;
        const cutoff = new Date(lastTs.getTime() - 24 * 60 * 60 * 1000);
        history = history.filter(function (s) {
          return s.timestamp >= cutoff;
        });

        // safety cap on number of points
        if (history.length > 500) {
          history = history.slice(history.length - 500);
        }

        saveHistoryToStorage(history);
      }

      /* ====== 4. Build series from history (real timestamps only) ====== */

      function buildSeriesFromHistory() {
        if (!history.length) return null;

        const labels = history.map(function (s) { return s.timestamp; });

        const csq1 = history.map(function (s) { return s.m1.csq || 0; });
        const csq2 = history.map(function (s) { return s.m2.csq || 0; });
        const rsrp1 = history.map(function (s) { return s.m1.rsrp || 0; });
        const rsrp2 = history.map(function (s) { return s.m2.rsrp || 0; });
        const rsrq1 = history.map(function (s) { return s.m1.rsrq || 0; });
        const rsrq2 = history.map(function (s) { return s.m2.rsrq || 0; });
        const rssi1 = history.map(function (s) { return s.m1.rssi || 0; });
        const rssi2 = history.map(function (s) { return s.m2.rssi || 0; });
        const snr1 = history.map(function (s) { return s.m1.snr || 0; });
        const snr2 = history.map(function (s) { return s.m2.snr || 0; });

        const firstTs = labels[0];
        const lastTs = labels[labels.length - 1];

        // add 15 minutes padding on both sides so point isn't at card edge
        const pad = 15 * 60 * 1000;
        const xMin = new Date(firstTs.getTime() - pad);
        const xMax = new Date(lastTs.getTime() + pad);

        const last = history[history.length - 1];

        return {
          labels: labels,
          xMin: xMin,
          xMax: xMax,
          csq1: csq1, csq2: csq2,
          rsrp1: rsrp1, rsrp2: rsrp2,
          rsrq1: rsrq1, rsrq2: rsrq2,
          rssi1: rssi1, rssi2: rssi2,
          snr1: snr1, snr2: snr2,
          operator1: last.m1.operator || '—',
          operator2: last.m2.operator || '—',
          nettype1: last.m1.nettype || '—',
          nettype2: last.m2.nettype || '—'
        };
      }

      function formatTimeHHMM(d) {
        // ensure nice HH:MM (24h) for tick labels
        return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      /* ====== 5. Draw charts with Plotly (points only at real times) ====== */

      function drawCharts(series) {
        if (!series) return;

        const labels = series.labels;

        const name1 = "Sim1 — " + series.operator1 +
          (series.nettype1 && series.nettype1 !== '—' ? " (" + series.nettype1 + ")" : "");
        const name2 = "Sim2 — " + series.operator2 +
          (series.nettype2 && series.nettype2 !== '—' ? " (" + series.nettype2 + ")" : "");

        const baseLayout = function (ytitle, yRange, yDtick) {
          return {
            margin: { l: 60, r: 20, t: 50, b: 60 },
            yaxis: {
              title: ytitle,
              range: yRange,
              dtick: yDtick,
              zeroline: false,
              gridcolor: '#e5e7eb'
            },
            xaxis: {
              type: 'date',
              range: [series.xMin, series.xMax],
              gridcolor: '#e5e7eb',
              tickmode: 'array',
              tickvals: labels,
              ticktext: labels.map(formatTimeHHMM),
              tickangle: 0
            },
            legend: { orientation: 'h', yanchor: 'bottom', y: 1.12, x: 0, xanchor: 'left' },
            plot_bgcolor: '#ffffff',
            paper_bgcolor: '#ffffff'
          };
        };

        Plotly.newPlot('cellular_signal_div_csq', [
          {
            x: labels,
            y: series.csq1,
            type: 'scatter',
            mode: 'lines+markers',
            name: name1,
            line: { color: '#ff7f0e', width: 3 },
            marker: { size: 7 }
          },
          {
            x: labels,
            y: series.csq2,
            type: 'scatter',
            mode: 'lines+markers',
            name: name2,
            line: { color: '#1f77b4', width: 3 },
            marker: { size: 7 }
          }
        ], baseLayout('CSQ', [0, 40], 5));

        Plotly.newPlot('cellular_signal_div_rsrp', [
          {
            x: labels,
            y: series.rsrp1,
            type: 'scatter',
            mode: 'lines+markers',
            name: name1,
            line: { color: '#ff7f0e' },
            marker: { size: 6 }
          },
          {
            x: labels,
            y: series.rsrp2,
            type: 'scatter',
            mode: 'lines+markers',
            name: name2,
            line: { color: '#1f77b4' },
            marker: { size: 6 }
          }
        ], baseLayout('RSRP (dBm)', [-140, -44], 20));

        Plotly.newPlot('cellular_signal_div_rsrq', [
          {
            x: labels,
            y: series.rsrq1,
            type: 'scatter',
            mode: 'lines+markers',
            name: name1,
            line: { color: '#ff7f0e' },
            marker: { size: 6 }
          },
          {
            x: labels,
            y: series.rsrq2,
            type: 'scatter',
            mode: 'lines+markers',
            name: name2,
            line: { color: '#1f77b4' },
            marker: { size: 6 }
          }
        ], baseLayout('RSRQ (dB)', [-20, -3], 2));

        Plotly.newPlot('cellular_signal_div_rssi', [
          {
            x: labels,
            y: series.rssi1,
            type: 'scatter',
            mode: 'lines+markers',
            name: name1,
            line: { color: '#ff7f0e' },
            marker: { size: 6 }
          },
          {
            x: labels,
            y: series.rssi2,
            type: 'scatter',
            mode: 'lines+markers',
            name: name2,
            line: { color: '#1f77b4' },
            marker: { size: 6 }
          }
        ], baseLayout('RSSI (dBm)', [-120, -40], 10));

        Plotly.newPlot('cellular_signal_div_snr', [
          {
            x: labels,
            y: series.snr1,
            type: 'scatter',
            mode: 'lines+markers',
            name: name1,
            line: { color: '#ff7f0e' },
            marker: { size: 6 }
          },
          {
            x: labels,
            y: series.snr2,
            type: 'scatter',
            mode: 'lines+markers',
            name: name2,
            line: { color: '#1f77b4' },
            marker: { size: 6 }
          }
        ], baseLayout('SNR (dB)', [-5, 35], 5));
      }

      /* ====== 6. Initial load: add Django sample, redraw, and show meta ====== */

      const firstSample = getSampleFromDjango();
      addSample(firstSample);
      const initialSeries = buildSeriesFromHistory();
      drawCharts(initialSeries);

      const metaEl = document.getElementById('cellular_signal_meta');
      if (metaEl) {
        metaEl.textContent =
          `M1: ${firstSample.m1.operator} • ${firstSample.m1.nettype} | ` +
          `M2: ${firstSample.m2.operator} • ${firstSample.m2.nettype}`;
      }

      /* ====== 7. Optional: function to add new sample without full page reload ====== */
      window.__addCellularSample = function (sample) {
        // sample should have { timestamp: Date, m1: {...}, m2: {...} }
        addSample(sample);
        drawCharts(buildSeriesFromHistory());
      };
    });
  </script>

</body>

</html>
