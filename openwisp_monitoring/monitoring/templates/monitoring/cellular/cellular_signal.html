<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Cellular Signal Charts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    .cellular_signal_page {
      max-width: 1100px;
      margin: 24px auto;
      padding: 0 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
    }

    .cellular_signal_header {
      display: flex;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 18px;
      flex-wrap: wrap;
    }

    .cellular_signal_title {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
    }

    .cellular_signal_subtitle {
      margin: 0;
      font-size: 14px;
      color: #666;
    }

    .cellular_signal_grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }

    .cellular_signal_card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, .06), 0 1px 2px rgba(0, 0, 0, .08);
      padding: 14px;
    }

    .cellular_signal_card h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    .cellular_signal_chartwrap {
      display: flex;
      justify-content: center;
    }

    .cellular_signal_plot {
      width: 100%;
      max-width: 1000px;
      height: 280px;
      margin: 0 auto;
    }

    .cellular_signal_plot.js-plotly-plot,
    .cellular_signal_plot .plot-container,
    .cellular_signal_plot .svg-container {
      width: 100% !important;
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #f3f4f6;
      font-size: 12px;
      color: #374151;
    }
  </style>
</head>

<body>

  <div class="cellular_signal_page">
    <div class="cellular_signal_header">
      <h1 class="cellular_signal_title">Cellular Metrics</h1>
      <p class="cellular_signal_subtitle" id="cellular_signal_meta"></p>
    </div>

    <div class="cellular_signal_grid">
      <div class="cellular_signal_card">
        <h3>Signal Strength (Level)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_csq" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>RSRP (dBm)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_rsrp" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>RSRQ (dB)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_rsrq" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>RSSI (dBm)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_rssi" class="cellular_signal_plot"></div>
        </div>
      </div>

      <div class="cellular_signal_card">
        <h3>SNR (dB)</h3>
        <div class="cellular_signal_chartwrap">
          <div id="cellular_signal_div_snr" class="cellular_signal_plot"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* Reads your Django robot-injected data for one sample */
    function getSampleData() {
      // Any real-time polling you do, replace this with actual API fetching logic

      const dd = new Date("{{ device_data.general.local_time|default:'2025-11-14T01:00:48+05:30' }}");

      function coerceNum(v) {
        if (v == null || v === '—' || v === '-' || v === '0' || v === 0) return 0;
        const n = parseFloat(v);
        return isNaN(n) ? 0 : n;
      }

      return {
        timestamp: dd,
        m1: {
          csq: coerceNum("{{ device_data.cellular.modem.csq|default:'—' }}"),
          rsrp: coerceNum("{{ device_data.cellular.modem.rsrp|default:'—' }}"),
          rsrq: coerceNum("{{ device_data.cellular.modem.rsrq|default:'—' }}"),
          rssi: coerceNum("{{ device_data.cellular.modem.rssi|default:'—' }}"),
          snr: coerceNum("{{ device_data.cellular.modem.sinr|default:'—' }}"),
          operator: "{{ device_data.cellular.modem.operator|default:'—' }}",
          nettype: "{{ device_data.cellular.modem.nettype|default:'—' }}"
        },
        m2: {
          csq: coerceNum("{{ device_data.cellular.modem2.csq|default:'—' }}"),
          rsrp: coerceNum("{{ device_data.cellular.modem2.rsrp|default:'—' }}"),
          rsrq: coerceNum("{{ device_data.cellular.modem2.rsrq|default:'—' }}"),
          rssi: coerceNum("{{ device_data.cellular.modem2.rssi|default:'—' }}"),
          snr: coerceNum("{{ device_data.cellular.modem2.sinr|default:'—' }}"),
          operator: "{{ device_data.cellular.modem2.operator|default:'—' }}",
          nettype: "{{ device_data.cellular.modem2.nettype|default:'—' }}"
        }
      }
    }

    /* We keep poll history and aggregate per hour (averaging) */
    let history = [];

    // Add sample every 5min, max keep 1 day (288 slots)
    function addSample(sample) {
      history.push(sample);
      if (history.length > 288) history.shift();
    }

    console.log('Initial sample data:====', history);

    // Returns array of hour strings (e.g. "01:00", "02:00"...) for last 24h from sample timestamp
    function hourlyLabels(baseDate) {
      const labels = [];
      const d = new Date(baseDate);
      d.setMinutes(0, 0, 0);
      for (let i = 0; i < 24; i++) {
        labels.unshift(d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        d.setHours(d.getHours() - 1);
      }
      return labels.reverse(); // oldest to newest on x-axis
    }

    // Average filters array ignoring zeros
    function average(values) {
      const nonZero = values.filter(v => v > 0);
      if (nonZero.length === 0) return 0;
      return nonZero.reduce((a, b) => a + b, 0) / nonZero.length;
    }

    // Aggregate to per-hour averages
    function aggregateHourly(history) {
      if (!history.length) return null;
      const result = {
        csq1: [], csq2: [], rsrp1: [], rsrp2: [], rsrq1: [], rsrq2: [],
        rssi1: [], rssi2: [], snr1: [], snr2: [],
        operator1: '—', operator2: '—', nettype1: '—', nettype2: '—'
      };
      // pick last sample's timestamp as base for hourly labels
      const baseTime = history[history.length - 1].timestamp;
      const labels = hourlyLabels(baseTime);
      const buckets = {};
      // Initialize buckets for each hour as array of values
      labels.forEach(label => {
        buckets[label] = { m1: [], m2: [] };
      });
      // Sort each sample into buckets by hour label aware of timezone
      history.forEach(entry => {
        const label = entry.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        if (!(label in buckets)) return; // outside 24h range
        buckets[label].m1.push(entry.m1);
        buckets[label].m2.push(entry.m2);
      });
      // For each bucket/h, average each metric from all samples
      labels.forEach(label => {
        const arrM1 = buckets[label].m1;
        const arrM2 = buckets[label].m2;
        // Helper to average one property
        function avgProp(arr, prop) {
          if (!arr.length) return 0;
          return average(arr.map(x => x[prop] || 0));
        }
        result.csq1.push(avgProp(arrM1, 'csq'));
        result.csq2.push(avgProp(arrM2, 'csq'));
        result.rsrp1.push(avgProp(arrM1, 'rsrp'));
        result.rsrp2.push(avgProp(arrM2, 'rsrp'));
        result.rsrq1.push(avgProp(arrM1, 'rsrq'));
        result.rsrq2.push(avgProp(arrM2, 'rsrq'));
        result.rssi1.push(avgProp(arrM1, 'rssi'));
        result.rssi2.push(avgProp(arrM2, 'rssi'));
        result.snr1.push(avgProp(arrM1, 'snr'));
        result.snr2.push(avgProp(arrM2, 'snr'));
      });
      // Use last sample metadata for legend
      const last = history[history.length - 1];
      result.operator1 = last.m1.operator || '—';
      result.operator2 = last.m2.operator || '—';
      result.nettype1 = last.m1.nettype || '—';
      result.nettype2 = last.m2.nettype || '—';
      return { labels, result };
    }

    // Draw charts using Plotly
    function drawCharts(data) {
      const { labels, result } = data;
      const name1 = "Sim1 — " + result.operator1 + (result.nettype1 ? " (" + result.nettype1 + ")" : "");
      const name2 = "Sim2 — " + result.operator2 + (result.nettype2 ? " (" + result.nettype2 + ")" : "");
      const baseLayout = (ytitle, yRange, yDtick) => ({
        margin: { l: 60, r: 20, t: 50, b: 80 },
        yaxis: { title: ytitle, range: yRange, dtick: yDtick, zeroline: false, gridcolor: '#e5e7eb' },
        xaxis: { tickvals: labels, ticktext: labels, gridcolor: '#e5e7eb', tickangle: -45 },
        legend: { orientation: 'h', yanchor: 'bottom', y: 1.12, x: 0, xanchor: 'left' },
        plot_bgcolor: '#fff',
        paper_bgcolor: '#fff'
      });

      Plotly.newPlot('cellular_signal_div_csq', [
        { x: labels, y: result.csq1, type: 'scatter', mode: 'lines+markers', name: name1, line: { color: '#ff7f0e', width: 3 }, marker: { size: 7 } },
        { x: labels, y: result.csq2, type: 'scatter', mode: 'lines+markers', name: name2, line: { color: '#1f77b4', width: 3 }, marker: { size: 7 } }
      ], baseLayout('CSQ', [0, 40], 5));

      Plotly.newPlot('cellular_signal_div_rsrp', [
        { x: labels, y: result.rsrp1, type: 'scatter', mode: 'lines+markers', name: name1, line: { color: '#ff7f0e' }, marker: { size: 6 } },
        { x: labels, y: result.rsrp2, type: 'scatter', mode: 'lines+markers', name: name2, line: { color: '#1f77b4' }, marker: { size: 6 } }
      ], baseLayout('RSRP (dBm)', [-140, -44], 20));

      Plotly.newPlot('cellular_signal_div_rsrq', [
        { x: labels, y: result.rsrq1, type: 'scatter', mode: 'lines+markers', name: name1, line: { color: '#ff7f0e' }, marker: { size: 6 } },
        { x: labels, y: result.rsrq2, type: 'scatter', mode: 'lines+markers', name: name2, line: { color: '#1f77b4' }, marker: { size: 6 } }
      ], baseLayout('RSRQ (dB)', [-20, -3], 2));

      Plotly.newPlot('cellular_signal_div_rssi', [
        { x: labels, y: result.rssi1, type: 'scatter', mode: 'lines+markers', name: name1, line: { color: '#ff7f0e' }, marker: { size: 6 } },
        { x: labels, y: result.rssi2, type: 'scatter', mode: 'lines+markers', name: name2, line: { color: '#1f77b4' }, marker: { size: 6 } }
      ], baseLayout('RSSI (dBm)', [-120, -40], 10));

      Plotly.newPlot('cellular_signal_div_snr', [
        { x: labels, y: result.snr1, type: 'scatter', mode: 'lines+markers', name: name1, line: { color: '#ff7f0e' }, marker: { size: 6 } },
        { x: labels, y: result.snr2, type: 'scatter', mode: 'lines+markers', name: name2, line: { color: '#1f77b4' }, marker: { size: 6 } }
      ], baseLayout('SNR (dB)', [-5, 35], 5));
    }

    // Initial data from Django injected variables
    function initialLoad() {
      const sample = getSampleData();
      addSample(sample);
      const data = aggregateHourly(history);
      drawCharts(data);
      // Update header meta
      const metaEl = document.getElementById('cellular_signal_meta');
      if (metaEl) {
        metaEl.textContent = `M1: ${sample.m1.operator} • ${sample.m1.nettype} | M2: ${sample.m2.operator} • ${sample.m2.nettype}`;
      }
    }

    // Periodic new sample arrival simulation every 5 minutes (replaced in prod with real backend async)
    setInterval(() => {
      const newSample = getSampleData(); // New sample from Django context or API
      addSample(newSample);
      const data = aggregateHourly(history);
      drawCharts(data);
      const metaEl = document.getElementById('cellular_signal_meta');
      if (metaEl) {
        metaEl.textContent = `M1: ${newSample.m1.operator} • ${newSample.m1.nettype} | M2: ${newSample.m2.operator} • ${newSample.m2.nettype}`;
      }
    }, 300000); // 300000 ms = 5 min

    initialLoad();

  </script>

</body>

</html>