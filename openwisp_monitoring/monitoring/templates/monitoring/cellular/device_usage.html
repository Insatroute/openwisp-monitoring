{% load i18n static %}
<link rel="preconnect" href="https://cdn.jsdelivr.net" />
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

<style>
  /* Page wrap */
  .du-wrap {
    max-width: 960px;
    margin: 24px auto;
    padding: 0 16px;
  }

  /* Card */
  .du-card {
    background: #fff;
    border: 1px solid #e8eaee;
    border-radius: 16px;
    box-shadow: 0 6px 24px rgba(16, 24, 40, .06);
    overflow: hidden;
  }

  .du-hd {
    padding: 16px 20px;
    border-bottom: 1px solid #e8eaee;
  }

  .du-title {
    margin: 0;
    font: 700 18px/1.3 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
    color: #0f172a;
  }

  .du-bd {
    padding: 18px 20px 22px;
  }

  /* Chart container: centered and sized nicely */
  .du-chart {
    margin: 0 auto;
    width: 100%;
    max-width: 720px;
    height: 360px;
  }
</style>

{{ device_data|json_script:"device-usage-data" }}

<div class="du-wrap">
  <section class="du-card">
    <div class="du-hd">
      <h3 class="du-title">{% trans "Wired Interfaces (eth0 / eth1)" %}</h3>
    </div>
    <div class="du-bd">
      <div id="du-chart-wired" class="du-chart"></div>
    </div>
  </section>
</div>

<script>
  /* ---------- STATIC FALLBACK (used only if device_data is missing/empty) ---------- */
  const FALLBACK_RESPONSE = {
    "type": "DeviceMonitoring",
    "interfaces": [
      {
        "type": "ethernet",
        "name": "eth0",
        "statistics": { "rx_bytes": 384568998, "tx_bytes": 49336767 }
      },
      {
        "type": "ethernet",
        "name": "eth1",
        "statistics": { "rx_bytes": 86859089, "tx_bytes": 249242488 }
      }
    ]
  };

  // Prefer JSON script (device_data); if missing or empty, use FALLBACK_RESPONSE
  const scriptEl = document.getElementById('device-usage-data');
  let source = {};
  try { source = scriptEl ? JSON.parse(scriptEl.textContent || '{}') : {}; } catch (_) { }
  console.log('Device Usage Source:====', source);
  if (!source || !Array.isArray(source.interfaces) || !source.interfaces.length) {
    source = FALLBACK_RESPONSE;
  }

  /* ---------- Helpers ---------- */
  const BYTES_PER_MB = 1024 * 1024;
  const toMB = b => (Number(b) || 0) / BYTES_PER_MB;

  /* ---------- Extract ethernet: eth0 & eth1 ---------- */
  const wanted = new Set(['eth0', 'eth1']);
  const ifaces = (source.interfaces || [])
    .filter(i => i && i.type === 'ethernet' && wanted.has(i.name))
    .sort((a, b) => (a.name > b.name ? 1 : -1)); // eth0 first

  const labels = ifaces.map(i => i.name);
  const rxMB = ifaces.map(i => toMB(i.statistics?.rx_bytes)); // Download
  const txMB = ifaces.map(i => toMB(i.statistics?.tx_bytes)); // Upload

  const noData = labels.length === 0;

  /* ---------- Plotly grouped bar chart ---------- */
  const traceDownload = {
    type: 'bar',
    name: '{% trans "Download (RX)" %}',
    x: labels,
    y: rxMB,
    marker: { color: '#1f77b4' },
    width: 0.1, /* roughly 20px width per bar */
    hovertemplate: '%{x}<br>{% trans "Download" %}: %{y:.2f} MB<extra></extra>'
  };
  const traceUpload = {
    type: 'bar',
    name: '{% trans "Upload (TX)" %}',
    x: labels,
    y: txMB,
    marker: { color: '#ff7f0e' },
    width: 0.1,
    hovertemplate: '%{x}<br>{% trans "Upload" %}: %{y:.2f} MB<extra></extra>'
  };

  const layout = {
    barmode: 'group',
    margin: { l: 60, r: 20, t: 10, b: 60 },
    xaxis: { title: '{% trans "Interface" %}', automargin: true },
    yaxis: { title: '{% trans "MB" %}', rangemode: 'tozero', automargin: true },
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    legend: {
      orientation: 'h',
      yanchor: 'top',
      y: -0.25,   // places legend below chart
      x: 0.5,
      xanchor: 'center'
    },
    annotations: noData ? [{
      text: '{% trans "No eth0/eth1 ethernet data" %}',
      xref: 'paper', yref: 'paper', x: 0.5, y: 0.5,
      showarrow: false, font: { size: 14, color: '#6b7280' }
    }] : []
  };

  Plotly.newPlot(
    'du-chart-wired',
    noData ? [] : [traceDownload, traceUpload],
    layout,
    { displaylogo: false, responsive: true, modeBarButtonsToRemove: ['select2d', 'lasso2d', 'autoScale2d'] }
  );
</script>