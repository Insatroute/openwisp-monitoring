{% load i18n static %}
<link rel="preconnect" href="https://cdn.jsdelivr.net" />
<script src="https://cdn.plot.ly/plotly-3.3.0.min.js"></script>

<!-- PDF export libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

<style>
  /* ===== Layout ===== */
  .dashboard-contain {
    margin: 14px auto;
  }

  .top-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    gap: 12px;
    flex-wrap: wrap;
  }
  .usage-title {
    font-size: 15px;
    font-weight: 600;
    margin: 0;
    color: #4b5563;
  }
  .top-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: flex-end;
  }

  .export-buttons {
    display: flex;
    gap: 6px;
  }
  .export-btn {
    border-radius: 6px;
    padding: 5px 10px;
    font-size: 12px;
    cursor: pointer;
    border: 1px solid #111827;
    background: #111827;
    color: #fff;
  }
  .export-btn.secondary {
    background: #253a5d;
    border-color: #253a5d;
  }
  .export-btn:hover {
    opacity: 0.92;
  }

  /* ===== Range Dropdown ===== */
  .range-dropdown {
    position: relative;
    display: inline-block;
  }
  .range-toggle {
    background: #253a5d;
    color: #fff;
    border: 1px solid #253a5d;
    border-radius: 6px;
    padding: 5px 10px;
    font-size: 12px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .range-toggle .caret {
    border-top: 4px solid #fff;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    width: 0;
    height: 0;
  }
  .range-menu {
    position: absolute;
    right: 0;
    top: 100%;
    z-index: 1000;
    min-width: 260px;
    background: #fff;
    border-radius: 8px;
    border: 1px solid #e5e7eb;
    padding: 4px 0 8px;
    margin-top: 6px;
    list-style: none;
    display: none;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
  }
  .range-menu.show {
    display: block;
  }
  .range-menu li {
    padding: 7px 12px;
    font-size: 13px;
    cursor: pointer;
  }
  .range-menu li:hover {
    background: #f3f4f6;
  }
  .range-menu li.divider {
    margin: 4px 0;
    padding: 0;
    border-top: 1px solid #e5e7eb;
    cursor: default;
  }
  .range-menu li.custom-header {
    cursor: default;
    padding: 6px 12px;
    background: #fee2e2;
    color: #b91c1c;
    font-weight: 600;
  }
  .range-menu li.custom-range-item {
    cursor: default;
  }

  .custom-range {
    padding: 8px 12px 4px;
  }
  .custom-range-label {
    font-size: 11px;
    color: #6b7280;
    margin-bottom: 2px;
  }
  .custom-range input[type="datetime-local"] {
    width: 100%;
    box-sizing: border-box;
    border-radius: 6px;
    border: 1px solid #e5e7eb;
    padding: 5px 7px;
    font-size: 12px;
    margin-bottom: 6px;
  }
  .custom-range-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 4px;
  }
  .cr-btn {
    border-radius: 999px;
    border: 1px solid transparent;
    padding: 4px 12px;
    font-size: 12px;
    cursor: pointer;
  }
  .cr-cancel {
    background: #e5e7eb;
    border-color: #d1d5db;
    color: #111827;
  }
  .cr-apply {
    background: #111827;
    border-color: #111827;
    color: #fff;
  }

  /* ===== 3 Panels Grid ===== */
  .usage-grid {
    display: grid;
    grid-template-columns: 1fr 2.4fr 1fr;
    gap: 12px;
    margin-bottom: 14px;
    align-items: start;
  }

  /* ===== Panels ===== */
  .ow-panel {
    border: 1px solid #e5e7eb;
    border-radius: 10px;
    background: #f9fafb;
    overflow: hidden;
  }
  .ow-panel-hd {
    padding: 8px 12px;
    color: #111827;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
    font-size: 13px;
    background: #f3f4f6;
  }
  .ow-panel-bd {
    background: #ffffff;
    padding: 2px;
  }
  .usage-panel-bd {
    padding: 10px;
  }

  .last-updated {
    font-size: 11px;
    color: #6b7280;
    font-weight: 500;
    white-space: nowrap;
  }
  .last-updated-val {
    font-weight: 500;
  }

  /* ===== Totals ===== */
  .total-summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 6px;
    padding: 0px 10px;
  }
  .total-value {
    font-size: 16px;
    font-weight: 800;
    color: #059669;
    line-height: 1.1;
  }
  .total-stats {
    font-size: 12px;
    color: #6b7280;
    line-height: 1.2;
    min-width: 120px;
  }
  .stat-row {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 8px;
    margin-top: 2px;
  }
  .stat-val {
    color: #111827;
    font-weight: 700;
    font-size: 11px;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  /* ===== Icon pill ===== */

  .io-pill {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    /*border-radius: 999px;
    border: 1px solid #e5e7eb;
    background: #fff;*/
    color: #16a34a;
  }
  .io-pill svg {
    width: 12px;
    height: 12px;
    display: block;
  }
  .io-pill.up svg {
    transform: translateY(-0.5px);
  }
  .io-pill.down svg {
    transform: translateY(0.5px);
  }

  /* ===== Cards ===== */
  .interface-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
  }
  .interface-card {
    background: #f8f8f8;
    /*border: 1px solid #e5e7eb;*/
    border-radius: 8px;
    padding: 10px;
  }
  .interface-row {
    display: flex;
    align-items: baseline;
    gap: 8px;
    justify-content: space-between;
    padding-right: 20px;
  }
  .interface-title {
    font-size: 12px;
    font-weight: 700;
    color: #374151;
    margin-bottom: 4px;
  }
  .interface-value {
    font-size: 14px;
    font-weight: 800;
    color: #059669;
    margin-bottom: 6px;
  }
  .interface-stats {
    font-size: 11px;
    color: #6b7280;
    line-height: 1.35;
    display: flex;
    flex-direction: column;
  }

  /* ===== Chart ===== */
  .chart-empty {
    display: none;
    font-size: 14px;
    font-weight: 700;
    color: #6b7280;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px 0;
  }
  .chart-inner {
    height: 240px;
  }
  #trafficCharts {
    width: 100%;
    height: 300px;
    max-width: 1100px;
    margin: 0 auto;
  }

  /* narrow panels: stack cards */
  .narrow-cards .interface-grid {
    grid-template-columns: 1fr;
  }

  @media (max-width: 1100px) {
    .usage-grid {
      grid-template-columns: 1fr;
    }
    .interface-grid {
      grid-template-columns: 1fr;
    }
  }
</style>

<div class="dashboard-contain">
  <div class="top-row">
    <h1 class="usage-title">Device Usage</h1>

    <div class="top-controls">
      <div class="export-buttons">
        <button type="button" class="export-btn secondary" id="exportExcelBtn">
          Export Excel
        </button>
        <button type="button" class="export-btn" id="exportPdfBtn">
          Export PDF
        </button>
      </div>

      <div class="range-dropdown" id="rangeDropdown">
        <button type="button" class="range-toggle" id="rangeToggle">
          <span id="currentRangeLabel">Loading…</span>
          <span class="caret"></span>
        </button>

        <ul class="range-menu" id="rangeMenu">
          <li data-query="&time=1d">Last 1 Day</li>
          <li data-query="&time=3d">Last 3 Days</li>
          <li data-query="&time=7d">Last 7 Days</li>
          <li data-query="&time=30d">Last 30 Days</li>
          <li data-query="&time=365d">Last 365 Days</li>

          <li class="divider"></li>

          <li class="custom-header">Custom Range</li>
          <li class="custom-range-item">
            <div class="custom-range">
              <div class="custom-range-label">From</div>
              <input type="datetime-local" id="crStart" />

              <div class="custom-range-label">To</div>
              <input type="datetime-local" id="crEnd" />

              <div class="custom-range-actions">
                <button type="button" class="cr-btn cr-cancel" id="crCancel">
                  Cancel
                </button>
                <button type="button" class="cr-btn cr-apply" id="crApply">
                  Apply
                </button>
              </div>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- 3 panels row -->
  <div class="usage-grid">
    <!-- Cellular -->
    <div class="ow-panel narrow-cards">
      <div class="ow-panel-hd"><span>Cellular</span></div>
      <div class="ow-panel-bd">
        <div class="usage-panel-bd">
          <div class="total-summary" id="cellular-total-summary">
            <div class="total-value">-</div>
            <div class="total-stats"></div>
          </div>

          <div class="interface-grid">
            <div class="interface-card" id="modem-card">
              <div class="interface-row">
                <div class="interface-title">SIM1</div>
                <div class="interface-value">-</div>
              </div>
              <div class="interface-stats"></div>
            </div>

            <div class="interface-card" id="modem2-card">
              <div class="interface-row">
                <div class="interface-title">SIM2</div>
                <div class="interface-value">-</div>
              </div>
              <div class="interface-stats"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Wired -->
    <div class="ow-panel">
      <div class="ow-panel-hd"><span>Wired</span></div>
      <div class="ow-panel-bd">
        <div class="usage-panel-bd">
          <div class="total-summary" id="wired-total-summary">
            <div class="total-value">-</div>
            <div class="total-stats"></div>
          </div>
          <div class="interface-grid" id="wiredInterfaces"></div>
        </div>
      </div>
    </div>

    <!-- WiFi -->
    <div class="ow-panel narrow-cards">
      <div class="ow-panel-hd"><span>WiFi</span></div>
      <div class="ow-panel-bd">
        <div class="usage-panel-bd">
          <div class="total-summary" id="wifi-total-summary">
            <div class="total-value">-</div>
            <div class="total-stats"></div>
          </div>
          <div class="interface-grid" id="wifiInterfaces"></div>
        </div>
      </div>
    </div>
  </div>
  <!-- Chart -->
  <div class="ow-panel">
    <div class="ow-panel-hd">
      <span>Data Usage Traffic</span>
      <span class="last-updated">
        Last Updated: {% if device_data.general.local_time %}
        {{ device_data.general.local_time }} {% else %} - {% endif %}
      </span>
    </div>

    <div class="ow-panel-bd">
      <div id="trafficEmpty" class="chart-empty">No usage data available</div>
      <div id="trafficCharts" class="chart-inner"></div>
    </div>
  </div>

  <div
    id="apiError"
    style="display: none; margin-top: 12px; color: #b91c1c; font-weight: 700"
  ></div>
</div>

<script>
  (function () {
    "use strict";

    const DEVICE_UUID = "{{ device.id }}";
    const API_BASE = window.location.origin;
    const TIMEZONE = "Asia/Calcutta";

    // Interfaces
    const MOBILE_IFACES = ["modem", "modem2"];
    const WIFI_IFACES = ["ra0", "rax0"];
    const ETH_IFACES = ["eth0", "eth1", "eth2", "eth3", "eth4", "eth5"];
    const ALL_IFACES = [...MOBILE_IFACES, ...WIFI_IFACES, ...ETH_IFACES];

    // default range
    let currentExtraQuery = "&time=1d";

    // server "now" derived from last sample
    let serverLastDate = null; // YYYY-MM-DD
    let serverLastTime = null; // HH:MM:SS

    // export cache
    let currentDailyUsage = null; // { rangeLabel, rows: [...] }

    /* ========= INLINE SVG ICONS ========= */
    function iconUpSVG() {
      return `
    <span class="io-pill up" title="Upload">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor" d="M12 2 3 11h6v11h6V11h6L12 2z"></path>
      </svg>
    </span>`;
    }

    function iconDownSVG() {
      return `
    <span class="io-pill down" title="Download">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor" d="M12 22 21 13h-6V2H9v11H3l9 9z"></path>
      </svg>
    </span>`;
    }

    /* ========= TIME HELPERS ========= */
    const hhmmToSeconds = (hm) => {
      if (!hm) return 0;
      const [h, m] = hm.split(":").map(Number);
      return (h || 0) * 3600 + (m || 0) * 60;
    };
    const hmsToSeconds = (hms) => {
      if (!hms) return 0;
      const [h, m, s] = hms.split(":").map(Number);
      return (h || 0) * 3600 + (m || 0) * 60 + (s || 0);
    };
    const secondsToHMS = (sec) => {
      sec = Math.max(0, Math.floor(sec));
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      const pad = (n) => n.toString().padStart(2, "0");
      return pad(h) + ":" + pad(m) + ":" + pad(s);
    };

    /* ========= UNITS (GB base) ========= */
    function chooseUnitFromGB(gbVal) {
      const gb = Math.abs(Number(gbVal) || 0);
      const mb = gb * 1000;
      const kb = mb * 1000;
      if (gb >= 1000) return "TB";
      if (mb >= 1000) return "GB";
      if (kb >= 1000) return "MB";
      return "KB";
    }
    function humanFromGB(gbVal) {
      const unit = chooseUnitFromGB(gbVal);
      const gb = Number(gbVal) || 0;
      let value;
      if (unit === "TB") value = gb / 1000;
      else if (unit === "GB") value = gb;
      else if (unit === "MB") value = gb * 1000;
      else value = gb * 1000 * 1000;
      return { value, unit };
    }
    function fmtGB(gbVal) {
      const { value, unit } = humanFromGB(gbVal);
      return value.toFixed(2) + " " + unit;
    }
    function factorFromGB(unit) {
      switch (unit) {
        case "TB":
          return 1 / 1000;
        case "GB":
          return 1;
        case "MB":
          return 1000;
        case "KB":
          return 1000 * 1000;
        default:
          return 1;
      }
    }

    /* ========= UI HELPERS ========= */
    function showError(message) {
      const el = document.getElementById("apiError");
      if (!el) return;
      el.style.display = "block";
      el.textContent = message;
    }
    function clearError() {
      const el = document.getElementById("apiError");
      if (!el) return;
      el.style.display = "none";
      el.textContent = "";
    }

    // remove time from "Last Updated"
    function trimLastUpdatedToDateOnly() {
      document.querySelectorAll(".last-updated-val").forEach((el) => {
        const t = (el.textContent || "").trim();
        if (!t || t === "-") return;
        el.textContent = t.split(",")[0].trim() || t;
      });
    }

    function ifaceLabel(name) {
      if (name === "ra0") return "Station";
      if (name === "rax0") return "Access Point";
      return name.toUpperCase();
    }

    function ensureCards(containerId, ifaces) {
      const wrap = document.getElementById(containerId);
      if (!wrap) return;
      if (wrap.dataset.ready === "1") return;

      wrap.innerHTML = ifaces
        .map(
          (iface) => `
      <div class="interface-card" id="${iface}-card">
        <div class="interface-row">
          <div class="interface-title">${ifaceLabel(iface)}</div>
          <div class="interface-value">-</div>
        </div>
        <div class="interface-stats"></div>
      </div>
    `
        )
        .join("");

      wrap.dataset.ready = "1";
    }

    function statsHtml(uploadGB, downloadGB) {
      return `
      <div class="stat-row">
        <span class="stat-val">${fmtGB(uploadGB)} ${iconUpSVG()}</span>
      </div>
      <div class="stat-row">
        <span class="stat-val">${fmtGB(downloadGB)} ${iconDownSVG()}</span>
      </div>
    `;
    }

    function updateCard(cardId, totalGB, uploadGB, downloadGB) {
      const card = document.getElementById(cardId);
      if (!card) return;

      const valueEl = card.querySelector(".interface-value");
      const statsEl = card.querySelector(".interface-stats");

      if (valueEl) valueEl.textContent = fmtGB(totalGB);
      if (statsEl) statsEl.innerHTML = statsHtml(uploadGB, downloadGB);
    }

    function updateSummary(summaryId, totalGB, uploadGB, downloadGB) {
      const block = document.getElementById(summaryId);
      if (!block) return;

      const valEl = block.querySelector(".total-value");
      const statsEl = block.querySelector(".total-stats");

      if (valEl) valEl.textContent = fmtGB(totalGB);
      if (statsEl) statsEl.innerHTML = statsHtml(uploadGB, downloadGB);
    }

    function formatDateHuman(tsStr) {
      if (!tsStr) return "";
      const [datePart] = tsStr.split(" ");
      const [y, m, d] = datePart.split("-").map(Number);
      const dt = new Date(y, m - 1, d);
      return new Intl.DateTimeFormat("en-GB", {
        day: "numeric",
        month: "long",
        year: "numeric",
      }).format(dt);
    }

    /* ========= DATA EXTRACTION ========= */
    function getChart(data, ifaceName) {
      if (!data || !Array.isArray(data.charts)) return null;
      const title = "Traffic: " + ifaceName;
      return data.charts.find((c) => c && c.title === title) || null;
    }

    function getSummaryGB(chart) {
      if (!chart || !chart.summary)
        return { uploadGB: 0, downloadGB: 0, totalGB: 0 };
      const up = Number(chart.summary.upload || 0);
      const down = Number(chart.summary.download || 0);
      return { uploadGB: up, downloadGB: down, totalGB: up + down };
    }

    function extractSeriesGB(chart, length) {
      const up = new Array(length).fill(0);
      const down = new Array(length).fill(0);
      if (!chart || !Array.isArray(chart.traces))
        return { upload: up, download: down };

      let rawUp = [];
      let rawDown = [];
      chart.traces.forEach((tr) => {
        if (!tr) return;
        if (tr[0] === "upload") rawUp = tr[1] || [];
        if (tr[0] === "download") rawDown = tr[1] || [];
      });

      for (let i = 0; i < length; i++) {
        up[i] = Number(rawUp[i] || 0);
        down[i] = Number(rawDown[i] || 0);
      }
      return { upload: up, download: down };
    }

    function getPerPointTotalsGB(chart, length) {
      const result = new Array(length).fill(0);
      if (!chart || !Array.isArray(chart.traces)) return result;

      let download = [];
      let upload = [];
      chart.traces.forEach((tr) => {
        if (!tr) return;
        if (tr[0] === "download") download = tr[1] || [];
        if (tr[0] === "upload") upload = tr[1] || [];
      });

      for (let i = 0; i < length; i++) {
        const dl = Number(download[i] || 0);
        const ul = Number(upload[i] || 0);
        result[i] = dl + ul;
      }
      return result;
    }

    /* ========= CUSTOM RANGE (MAX) ========= */
    const crStartInput = document.getElementById("crStart");
    const crEndInput = document.getElementById("crEnd");

    function applyCustomRangeMax() {
      if (!crStartInput || !crEndInput) return;

      let dateStr = serverLastDate;
      let timeStr = serverLastTime;

      if (!dateStr || !timeStr) {
        const now = new Date();
        dateStr = now.toISOString().slice(0, 10);
        timeStr = now.toTimeString().slice(0, 8);
      }

      const maxVal = dateStr + "T" + timeStr.slice(0, 5);
      crStartInput.setAttribute("max", maxVal);
      crEndInput.setAttribute("max", maxVal);
    }

    /* ========= DAILY USAGE (for export) ========= */
    function round3(v) {
      return Math.round((Number(v) || 0) * 1000) / 1000;
    }

    function buildDailyUsageDynamic(x, chartsByIface) {
      const n = x.length;
      const series = {};
      ALL_IFACES.forEach((iface) => {
        series[iface] = extractSeriesGB(chartsByIface[iface], n);
      });

      const days = {};
      for (let i = 0; i < n; i++) {
        const ts = x[i] || "";
        const day = ts.split(" ")[0];
        if (!day) continue;

        if (!days[day]) {
          days[day] = {
            modemUp: 0,
            modemDown: 0,
            modem2Up: 0,
            modem2Down: 0,
            wifi: Object.fromEntries(
              WIFI_IFACES.map((w) => [w, { up: 0, down: 0 }])
            ),
            eth: Object.fromEntries(
              ETH_IFACES.map((e) => [e, { up: 0, down: 0 }])
            ),
          };
        }
        const d = days[day];

        d.modemUp += series.modem.upload[i];
        d.modemDown += series.modem.download[i];
        d.modem2Up += series.modem2.upload[i];
        d.modem2Down += series.modem2.download[i];

        WIFI_IFACES.forEach((w) => {
          d.wifi[w].up += series[w].upload[i];
          d.wifi[w].down += series[w].download[i];
        });
        ETH_IFACES.forEach((e) => {
          d.eth[e].up += series[e].upload[i];
          d.eth[e].down += series[e].download[i];
        });
      }

      const dates = Object.keys(days).sort();
      const rows = [];

      dates.forEach((date) => {
        const d = days[date];

        const sim1Up = round3(d.modemUp),
          sim1Down = round3(d.modemDown),
          sim1Total = round3(sim1Up + sim1Down);
        const sim2Up = round3(d.modem2Up),
          sim2Down = round3(d.modem2Down),
          sim2Total = round3(sim2Up + sim2Down);

        const cellularUp = round3(sim1Up + sim2Up);
        const cellularDown = round3(sim1Down + sim2Down);
        const cellularTotal = round3(cellularUp + cellularDown);

        const wifiObj = {};
        WIFI_IFACES.forEach((w) => {
          const up = round3(d.wifi[w].up),
            down = round3(d.wifi[w].down);
          wifiObj[w] = { up, down, total: round3(up + down) };
        });
        let wifiUp = 0,
          wifiDown = 0;
        WIFI_IFACES.forEach((w) => {
          wifiUp += wifiObj[w].up;
          wifiDown += wifiObj[w].down;
        });
        wifiUp = round3(wifiUp);
        wifiDown = round3(wifiDown);
        const wifiTotal = round3(wifiUp + wifiDown);

        const ethObj = {};
        ETH_IFACES.forEach((e) => {
          const up = round3(d.eth[e].up),
            down = round3(d.eth[e].down);
          ethObj[e] = { up, down, total: round3(up + down) };
        });
        let wiredUp = 0,
          wiredDown = 0;
        ETH_IFACES.forEach((e) => {
          wiredUp += ethObj[e].up;
          wiredDown += ethObj[e].down;
        });
        wiredUp = round3(wiredUp);
        wiredDown = round3(wiredDown);
        const wiredTotal = round3(wiredUp + wiredDown);

        const grandTotal = round3(cellularTotal + wifiTotal + wiredTotal);

        rows.push({
          date,
          sim1Up,
          sim1Down,
          sim1Total,
          sim2Up,
          sim2Down,
          sim2Total,
          cellularUp,
          cellularDown,
          cellularTotal,
          wifi: wifiObj,
          wifiUp,
          wifiDown,
          wifiTotal,
          eth: ethObj,
          wiredUp,
          wiredDown,
          wiredTotal,
          grandTotal,
          isTotalRow: false,
        });
      });

      // TOTAL row
      if (rows.length) {
        const totals = {
          sim1Up: 0,
          sim1Down: 0,
          sim1Total: 0,
          sim2Up: 0,
          sim2Down: 0,
          sim2Total: 0,
          cellularUp: 0,
          cellularDown: 0,
          cellularTotal: 0,
          wifi: Object.fromEntries(
            WIFI_IFACES.map((w) => [w, { up: 0, down: 0, total: 0 }])
          ),
          wifiUp: 0,
          wifiDown: 0,
          wifiTotal: 0,
          eth: Object.fromEntries(
            ETH_IFACES.map((e) => [e, { up: 0, down: 0, total: 0 }])
          ),
          wiredUp: 0,
          wiredDown: 0,
          wiredTotal: 0,
          grandTotal: 0,
        };

        rows.forEach((r) => {
          totals.sim1Up += r.sim1Up;
          totals.sim1Down += r.sim1Down;
          totals.sim1Total += r.sim1Total;
          totals.sim2Up += r.sim2Up;
          totals.sim2Down += r.sim2Down;
          totals.sim2Total += r.sim2Total;
          totals.cellularUp += r.cellularUp;
          totals.cellularDown += r.cellularDown;
          totals.cellularTotal += r.cellularTotal;

          WIFI_IFACES.forEach((w) => {
            totals.wifi[w].up += r.wifi[w].up;
            totals.wifi[w].down += r.wifi[w].down;
            totals.wifi[w].total += r.wifi[w].total;
          });
          totals.wifiUp += r.wifiUp;
          totals.wifiDown += r.wifiDown;
          totals.wifiTotal += r.wifiTotal;

          ETH_IFACES.forEach((e) => {
            totals.eth[e].up += r.eth[e].up;
            totals.eth[e].down += r.eth[e].down;
            totals.eth[e].total += r.eth[e].total;
          });
          totals.wiredUp += r.wiredUp;
          totals.wiredDown += r.wiredDown;
          totals.wiredTotal += r.wiredTotal;

          totals.grandTotal += r.grandTotal;
        });

        const keys = [
          "sim1Up",
          "sim1Down",
          "sim1Total",
          "sim2Up",
          "sim2Down",
          "sim2Total",
          "cellularUp",
          "cellularDown",
          "cellularTotal",
          "wifiUp",
          "wifiDown",
          "wifiTotal",
          "wiredUp",
          "wiredDown",
          "wiredTotal",
          "grandTotal",
        ];
        keys.forEach((k) => (totals[k] = round3(totals[k])));
        WIFI_IFACES.forEach((w) => {
          totals.wifi[w].up = round3(totals.wifi[w].up);
          totals.wifi[w].down = round3(totals.wifi[w].down);
          totals.wifi[w].total = round3(totals.wifi[w].total);
        });
        ETH_IFACES.forEach((e) => {
          totals.eth[e].up = round3(totals.eth[e].up);
          totals.eth[e].down = round3(totals.eth[e].down);
          totals.eth[e].total = round3(totals.eth[e].total);
        });

        rows.push({
          date: "TOTAL",
          sim1Up: totals.sim1Up,
          sim1Down: totals.sim1Down,
          sim1Total: totals.sim1Total,
          sim2Up: totals.sim2Up,
          sim2Down: totals.sim2Down,
          sim2Total: totals.sim2Total,
          cellularUp: totals.cellularUp,
          cellularDown: totals.cellularDown,
          cellularTotal: totals.cellularTotal,
          wifi: totals.wifi,
          wifiUp: totals.wifiUp,
          wifiDown: totals.wifiDown,
          wifiTotal: totals.wifiTotal,
          eth: totals.eth,
          wiredUp: totals.wiredUp,
          wiredDown: totals.wiredDown,
          wiredTotal: totals.wiredTotal,
          grandTotal: totals.grandTotal,
          isTotalRow: true,
        });
      }

      return rows;
    }

    /* ========= RENDER ========= */
    function renderMonitoring(data) {
      const x = Array.isArray(data.x) ? data.x : [];
      const chartDiv = document.getElementById("trafficCharts");
      const emptyDiv = document.getElementById("trafficEmpty");

      if (!x.length) {
        if (chartDiv) chartDiv.innerHTML = "";
        if (emptyDiv) emptyDiv.style.display = "flex";
        return;
      } else {
        if (emptyDiv) emptyDiv.style.display = "none";
      }

      const lastTs = x[x.length - 1];
      const lastParts = (lastTs || "").split(" ");
      if (lastParts.length >= 2) {
        serverLastDate = lastParts[0];
        serverLastTime = lastParts[1];
        applyCustomRangeMax();
      }

      const rangeLabelText =
        formatDateHuman(x[0]) + " – " + formatDateHuman(lastTs);
      const rangeLabelEl = document.getElementById("currentRangeLabel");
      if (rangeLabelEl) rangeLabelEl.textContent = rangeLabelText;

      ensureCards("wifiInterfaces", WIFI_IFACES);
      ensureCards("wiredInterfaces", ETH_IFACES);

      const chartsByIface = {};
      const sumsByIface = {};
      ALL_IFACES.forEach((iface) => {
        chartsByIface[iface] = getChart(data, iface);
        sumsByIface[iface] = getSummaryGB(chartsByIface[iface]);
      });

      updateCard(
        "modem-card",
        sumsByIface.modem.totalGB,
        sumsByIface.modem.uploadGB,
        sumsByIface.modem.downloadGB
      );
      updateCard(
        "modem2-card",
        sumsByIface.modem2.totalGB,
        sumsByIface.modem2.uploadGB,
        sumsByIface.modem2.downloadGB
      );

      WIFI_IFACES.forEach((w) =>
        updateCard(
          `${w}-card`,
          sumsByIface[w].totalGB,
          sumsByIface[w].uploadGB,
          sumsByIface[w].downloadGB
        )
      );
      ETH_IFACES.forEach((e) =>
        updateCard(
          `${e}-card`,
          sumsByIface[e].totalGB,
          sumsByIface[e].uploadGB,
          sumsByIface[e].downloadGB
        )
      );

      let cellularUploadGB = 0,
        cellularDownloadGB = 0;
      MOBILE_IFACES.forEach((m) => {
        cellularUploadGB += sumsByIface[m].uploadGB;
        cellularDownloadGB += sumsByIface[m].downloadGB;
      });
      updateSummary(
        "cellular-total-summary",
        cellularUploadGB + cellularDownloadGB,
        cellularUploadGB,
        cellularDownloadGB
      );

      let wifiUploadGB = 0,
        wifiDownloadGB = 0;
      WIFI_IFACES.forEach((w) => {
        wifiUploadGB += sumsByIface[w].uploadGB;
        wifiDownloadGB += sumsByIface[w].downloadGB;
      });
      updateSummary(
        "wifi-total-summary",
        wifiUploadGB + wifiDownloadGB,
        wifiUploadGB,
        wifiDownloadGB
      );

      let wiredUploadGB = 0,
        wiredDownloadGB = 0;
      ETH_IFACES.forEach((e) => {
        wiredUploadGB += sumsByIface[e].uploadGB;
        wiredDownloadGB += sumsByIface[e].downloadGB;
      });
      updateSummary(
        "wired-total-summary",
        wiredUploadGB + wiredDownloadGB,
        wiredUploadGB,
        wiredDownloadGB
      );

      currentDailyUsage = {
        rangeLabel: rangeLabelText,
        rows: buildDailyUsageDynamic(x, chartsByIface),
      };

      // chart series
      const pointsCount = x.length;
      const sumPerPointTotals = (ifaces) => {
        const out = new Array(pointsCount).fill(0);
        ifaces.forEach((iface) => {
          const s = getPerPointTotalsGB(chartsByIface[iface], pointsCount);
          for (let i = 0; i < pointsCount; i++) out[i] += Number(s[i] || 0);
        });
        return out;
      };

      const cellularSeriesGB = sumPerPointTotals(MOBILE_IFACES);
      const wifiSeriesGB = sumPerPointTotals(WIFI_IFACES);
      const wiredSeriesGB = sumPerPointTotals(ETH_IFACES);

      const cellularTotalGB = cellularUploadGB + cellularDownloadGB;
      const wifiTotalGB = wifiUploadGB + wifiDownloadGB;
      const wiredTotalGB = wiredUploadGB + wiredDownloadGB;

      const worstTotalGB = Math.max(cellularTotalGB, wifiTotalGB, wiredTotalGB);
      const axisUnit = chooseUnitFromGB(worstTotalGB);
      const axisFactor = factorFromGB(axisUnit);

      const cellularSeries = cellularSeriesGB.map(
        (v) => (Number(v) || 0) * axisFactor
      );
      const wifiSeries = wifiSeriesGB.map((v) => (Number(v) || 0) * axisFactor);
      const wiredSeries = wiredSeriesGB.map(
        (v) => (Number(v) || 0) * axisFactor
      );

      const totalSeries = cellularSeries.map(
        (v, i) =>
          (Number(v) || 0) +
          (Number(wifiSeries[i]) || 0) +
          (Number(wiredSeries[i]) || 0)
      );

      const xISO = x.map((ts) => (ts || "").replace(" ", "T"));

      const traces = [
        {
          type: "bar",
          name: "Cellular",
          x: xISO,
          y: cellularSeries,
          hovertemplate: `Cellular: %{y:.2f} ${axisUnit}<extra></extra>`,
        },
        {
          type: "bar",
          name: "WiFi",
          x: xISO,
          y: wifiSeries,
          hovertemplate: `WiFi: %{y:.2f} ${axisUnit}<extra></extra>`,
        },
        {
          type: "bar",
          name: "Wired",
          x: xISO,
          y: wiredSeries,
          hovertemplate: `Wired: %{y:.2f} ${axisUnit}<extra></extra>`,
        },
        {
          type: "scatter",
          mode: "markers+lines",
          name: "Total",
          x: xISO,
          y: totalSeries,
          line: { width: 2, color: "#6b7280" },
          marker: { size: 5, color: "#6b7280" },
          hovertemplate: `Total: %{y:.2f} ${axisUnit}<extra></extra>`,
        },
      ];

      const layout = {
        barmode: "stack",
        bargap: 0.45,
        margin: { l: 58, r: 16, t: 30, b: 60 },
        hovermode: "x unified",
        xaxis: {
          type: "date",
          tickformat: "%H:%M<br>%b %d, %Y",
          nticks: 8,
          showgrid: false,
          showspikes: true,
          spikemode: "across",
          spikesnap: "cursor",
          spikedash: "dot",
          spikecolor: "#111827",
          spikethickness: 1,
        },
        yaxis: {
          title: { text: `Data usage (${axisUnit})`, standoff: 12 },
          rangemode: "tozero",
          showgrid: true,
          gridcolor: "#e5e7eb",
          zeroline: false,
          automargin: true,
        },
        legend: { orientation: "h", x: 0.5, xanchor: "center", y: -0.25 },
        paper_bgcolor: "#ffffff",
        plot_bgcolor: "#ffffff",
      };

      const trafficChartsEl = document.getElementById("trafficCharts");
      if (!trafficChartsEl) return;

      Plotly.newPlot(trafficChartsEl, traces, layout, {
        responsive: true,
        displaylogo: false,
        displayModeBar: true,
      }).then(() => {
        const resizeTrafficChart = () => Plotly.Plots.resize(trafficChartsEl);
        requestAnimationFrame(resizeTrafficChart);
        setTimeout(resizeTrafficChart, 200);
        window.addEventListener("resize", resizeTrafficChart);
        window.addEventListener("orientationchange", resizeTrafficChart);
      });
    }

    /* ========= FETCH ========= */
    async function loadMonitoring() {
      if (!DEVICE_UUID) {
        showError("Device UUID is missing in template.");
        return;
      }
      clearError();

      const url =
        API_BASE +
        "/api/v1/monitoring/device/" +
        encodeURIComponent(DEVICE_UUID) +
        "/?timezone=" +
        encodeURIComponent(TIMEZONE) +
        (currentExtraQuery || "");

      try {
        const resp = await fetch(url, {
          method: "GET",
          credentials: "same-origin",
        });
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        const data = await resp.json();
        renderMonitoring(data);
      } catch (err) {
        console.error(err);
        showError("Failed to load device usage data from monitoring API.");
      }
    }

    /* ========= RANGE + CUSTOM RANGE ========= */
    const rangeDropdown = document.getElementById("rangeDropdown");
    const rangeToggle = document.getElementById("rangeToggle");
    const rangeMenu = document.getElementById("rangeMenu");
    const crApplyBtn = document.getElementById("crApply");
    const crCancelBtn = document.getElementById("crCancel");

    if (rangeToggle && rangeMenu && rangeDropdown) {
      rangeToggle.addEventListener("click", function (e) {
        e.stopPropagation();
        rangeMenu.classList.toggle("show");
      });

      rangeMenu.addEventListener("click", function (e) {
        const li = e.target.closest("li[data-query]");
        if (!li) return;
        currentExtraQuery = li.getAttribute("data-query") || "";
        rangeMenu.classList.remove("show");
        loadMonitoring();
      });

      document.addEventListener("click", function (e) {
        if (!rangeDropdown.contains(e.target))
          rangeMenu.classList.remove("show");
      });
    }

    if (crApplyBtn) {
      crApplyBtn.addEventListener("click", function () {
        const startRaw = crStartInput.value;
        const endRaw = crEndInput.value;

        if (!startRaw || !endRaw) {
          alert("Please select both start and end for the custom range.");
          return;
        }

        const [startDate, startTimeRaw] = startRaw.split("T");
        const [endDateRaw, endTimeRaw] = endRaw.split("T");

        let sDate = startDate;
        let eDate = endDateRaw;

        let limitDate = serverLastDate;
        let limitTime = serverLastTime;
        if (!limitDate || !limitTime) {
          const now = new Date();
          limitDate = now.toISOString().slice(0, 10);
          limitTime = now.toTimeString().slice(0, 8);
        }

        if (eDate > limitDate) eDate = limitDate;
        if (sDate > eDate) {
          alert("Start date cannot be greater than end date.");
          return;
        }

        let sTime = "00:00:00";
        if (startTimeRaw) sTime = startTimeRaw + ":00";

        let eTime;
        if (eDate < limitDate) {
          eTime = "23:59:59";
        } else {
          const userHM = endTimeRaw || "23:59";
          const userSec = hhmmToSeconds(userHM);
          const serverSec = hmsToSeconds(limitTime);
          eTime = secondsToHMS(Math.min(userSec, serverSec));
        }

        const startApi = sDate + " " + sTime;
        const endApi = eDate + " " + eTime;

        currentExtraQuery =
          "&start=" +
          encodeURIComponent(startApi) +
          "&end=" +
          encodeURIComponent(endApi);
        rangeMenu.classList.remove("show");
        loadMonitoring();
      });
    }

    if (crCancelBtn) {
      crCancelBtn.addEventListener("click", function () {
        if (crStartInput) crStartInput.value = "";
        if (crEndInput) crEndInput.value = "";
        rangeMenu.classList.remove("show");
      });
    }

    /* ========= EXPORTS ========= */
    function exportExcel() {
      if (
        !currentDailyUsage ||
        !currentDailyUsage.rows ||
        !currentDailyUsage.rows.length
      ) {
        alert("No data available to export yet.");
        return;
      }

      const rows = currentDailyUsage.rows;

      const header1 = [
        "Date",
        "SIM1 (GB)",
        "",
        "",
        "SIM2 (GB)",
        "",
        "",
        "Cellular Total (GB)",
        "",
        "",
        ...WIFI_IFACES.flatMap((w) => [ifaceLabel(w) + " (GB)", "", ""]),
        "WiFi Total (GB)",
        "",
        "",
        ...ETH_IFACES.flatMap((e) => [e.toUpperCase() + " (GB)", "", ""]),
        "Wired Total (GB)",
        "",
        "",
        "Grand Total (GB)",
      ];

      const header2 = [
        "",
        "Up",
        "Down",
        "Total",
        "Up",
        "Down",
        "Total",
        "Up",
        "Down",
        "Total",
        ...WIFI_IFACES.flatMap(() => ["Up", "Down", "Total"]),
        "Up",
        "Down",
        "Total",
        ...ETH_IFACES.flatMap(() => ["Up", "Down", "Total"]),
        "Up",
        "Down",
        "Total",
        "Total",
      ];

      let csv = header1.join(",") + "\n" + header2.join(",") + "\n";

      rows.forEach((r) => {
        const parts = [
          r.date,
          r.sim1Up.toFixed(3),
          r.sim1Down.toFixed(3),
          r.sim1Total.toFixed(3),
          r.sim2Up.toFixed(3),
          r.sim2Down.toFixed(3),
          r.sim2Total.toFixed(3),
          r.cellularUp.toFixed(3),
          r.cellularDown.toFixed(3),
          r.cellularTotal.toFixed(3),
        ];

        WIFI_IFACES.forEach((w) => {
          const o = r.wifi[w] || { up: 0, down: 0, total: 0 };
          parts.push(o.up.toFixed(3), o.down.toFixed(3), o.total.toFixed(3));
        });

        parts.push(
          r.wifiUp.toFixed(3),
          r.wifiDown.toFixed(3),
          r.wifiTotal.toFixed(3)
        );

        ETH_IFACES.forEach((e) => {
          const o = r.eth[e] || { up: 0, down: 0, total: 0 };
          parts.push(o.up.toFixed(3), o.down.toFixed(3), o.total.toFixed(3));
        });

        parts.push(
          r.wiredUp.toFixed(3),
          r.wiredDown.toFixed(3),
          r.wiredTotal.toFixed(3),
          r.grandTotal.toFixed(3)
        );

        csv += parts.join(",") + "\n";
      });

      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "device-usage-daily-detailed.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportPdf() {
      if (
        !currentDailyUsage ||
        !currentDailyUsage.rows ||
        !currentDailyUsage.rows.length
      ) {
        alert("No data available to export yet.");
        return;
      }
      if (!window.jspdf || !window.jspdf.jsPDF) {
        alert("PDF export library not loaded.");
        return;
      }

      const rows = currentDailyUsage.rows;
      const totalIndex = rows.length - 1;

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ orientation: "landscape" });

      doc.setFontSize(13);
      doc.text("Device Usage – Daily Summary", 14, 14);

      doc.setFontSize(9);
      if (currentDailyUsage.rangeLabel)
        doc.text("Range: " + currentDailyUsage.rangeLabel, 14, 20);

      const headRow1 = [
        { content: "Date", rowSpan: 2 },
        { content: "SIM1", colSpan: 3, styles: { halign: "center" } },
        { content: "SIM2", colSpan: 3, styles: { halign: "center" } },
        { content: "Cellular Total", colSpan: 3, styles: { halign: "center" } },
        ...WIFI_IFACES.map((w) => ({
          content: ifaceLabel(w),
          colSpan: 3,
          styles: { halign: "center" },
        })),
        { content: "WiFi Total", colSpan: 3, styles: { halign: "center" } },
        ...ETH_IFACES.map((e) => ({
          content: e.toUpperCase(),
          colSpan: 3,
          styles: { halign: "center" },
        })),
        { content: "Wired Total", colSpan: 3, styles: { halign: "center" } },
        { content: "Grand Total", rowSpan: 2, styles: { halign: "center" } },
      ];

      const headRow2 = [
        "Up",
        "Down",
        "Total",
        "Up",
        "Down",
        "Total",
        "Up",
        "Down",
        "Total",
        ...WIFI_IFACES.flatMap(() => ["Up", "Down", "Total"]),
        "Up",
        "Down",
        "Total",
        ...ETH_IFACES.flatMap(() => ["Up", "Down", "Total"]),
        "Up",
        "Down",
        "Total",
      ];

      const head = [headRow1, headRow2];

      const body = rows.map((r) => {
        const row = [
          r.date,
          r.sim1Up.toFixed(3),
          r.sim1Down.toFixed(3),
          r.sim1Total.toFixed(3),
          r.sim2Up.toFixed(3),
          r.sim2Down.toFixed(3),
          r.sim2Total.toFixed(3),
          r.cellularUp.toFixed(3),
          r.cellularDown.toFixed(3),
          r.cellularTotal.toFixed(3),
        ];

        WIFI_IFACES.forEach((w) => {
          const o = r.wifi[w] || { up: 0, down: 0, total: 0 };
          row.push(o.up.toFixed(3), o.down.toFixed(3), o.total.toFixed(3));
        });

        row.push(
          r.wifiUp.toFixed(3),
          r.wifiDown.toFixed(3),
          r.wifiTotal.toFixed(3)
        );

        ETH_IFACES.forEach((e) => {
          const o = r.eth[e] || { up: 0, down: 0, total: 0 };
          row.push(o.up.toFixed(3), o.down.toFixed(3), o.total.toFixed(3));
        });

        row.push(
          r.wiredUp.toFixed(3),
          r.wiredDown.toFixed(3),
          r.wiredTotal.toFixed(3)
        );
        row.push(r.grandTotal.toFixed(3));

        return row;
      });

      // colors
      const SIM_HEADER = [75, 85, 99];
      const WIFI_HEADER = [21, 128, 61];
      const ETH_HEADER = [180, 83, 9];
      const OTHER_HEADER = [55, 65, 81];

      const SIM_BODY = [229, 231, 235];
      const WIFI_BODY = [220, 252, 231];
      const ETH_BODY = [254, 243, 199];
      const OTHER_BODY = [243, 244, 246];
      const TOTAL_BODY = [229, 231, 235];

      // column groups
      const simCols = [];
      for (let i = 1; i <= 9; i++) simCols.push(i);

      let idx = 10;
      const wifiCols = [];
      for (let i = 0; i < WIFI_IFACES.length * 3; i++) wifiCols.push(idx + i);
      idx += WIFI_IFACES.length * 3;
      wifiCols.push(idx, idx + 1, idx + 2);
      idx += 3;

      const ethCols = [];
      for (let i = 0; i < ETH_IFACES.length * 3; i++) ethCols.push(idx + i);
      idx += ETH_IFACES.length * 3;
      ethCols.push(idx, idx + 1, idx + 2);
      idx += 3;

      const grandCol = idx;

      doc.autoTable({
        head,
        body,
        startY: 26,
        styles: { fontSize: 6.1, cellPadding: 1.5 },
        headStyles: {
          fillColor: OTHER_HEADER,
          textColor: 255,
          halign: "center",
          valign: "middle",
        },
        didParseCell(data) {
          const col = data.column.index;

          if (data.section === "head") {
            if (simCols.includes(col)) data.cell.styles.fillColor = SIM_HEADER;
            else if (wifiCols.includes(col))
              data.cell.styles.fillColor = WIFI_HEADER;
            else if (ethCols.includes(col))
              data.cell.styles.fillColor = ETH_HEADER;
            else data.cell.styles.fillColor = OTHER_HEADER;
            data.cell.styles.textColor = 255;
          }

          if (data.section === "body") {
            const isTotalRow = data.row.index === totalIndex;

            if (simCols.includes(col)) data.cell.styles.fillColor = SIM_BODY;
            else if (wifiCols.includes(col))
              data.cell.styles.fillColor = WIFI_BODY;
            else if (ethCols.includes(col))
              data.cell.styles.fillColor = ETH_BODY;
            else
              data.cell.styles.fillColor = isTotalRow ? TOTAL_BODY : OTHER_BODY;

            if (isTotalRow || col === grandCol)
              data.cell.styles.fontStyle = "bold";
          }
        },
      });

      doc.save("device-usage-daily-detailed.pdf");
    }

    /* ========= DOM READY ========= */
    document.addEventListener("DOMContentLoaded", function () {
      ensureCards("wifiInterfaces", WIFI_IFACES);
      ensureCards("wiredInterfaces", ETH_IFACES);

      trimLastUpdatedToDateOnly(); // remove time in headers
      applyCustomRangeMax();
      loadMonitoring();

      const excelBtn = document.getElementById("exportExcelBtn");
      const pdfBtn = document.getElementById("exportPdfBtn");
      if (excelBtn) excelBtn.addEventListener("click", exportExcel);
      if (pdfBtn) pdfBtn.addEventListener("click", exportPdf);
    });
  })();
</script>
